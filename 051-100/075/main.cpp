/*
 * Project Euler - Problem 75
 * Singular Integer Right Triangles
 *
 * A primitive Pythagorean triple is a triple (a, b, c) such that
 *
 *             a^2 + b^2 = c^2 and gcd(a, b, c) = 1
 * 
 * so (3, 4, 5) is a primitive Pythagorean triple, but (6, 8, 10) is not (it is
 * a non-primitive Pythagorean triple). Given a primitive triple (a, b, c),
 * three new triple can be generated via the following transformations
 *
 *          | 1  2  2 |             | 1  2  2 |             |-1 -2 -2 |
 * (a, b, c)|-2 -1 -2 |    (a, b, c)| 2  1  2 |    (a, b, c)| 2  1  2 |
 *          | 2  2  3 |             | 2  2  3 |             | 2  2  3 |
 *
 * In fact *all* primitive triples can be generated by multiplying (3, 4, 5) by
 * some finite product of the above three matrices. That is, if the three 
 * matrices are called U, A, D, then 
 *
 *                        (a, b, c)U
 *                        (a, b, c)UA
 *                        (a, b, c)UAU
 *                        (a, b, c)UAUD
 *                        etc.
 *
 * are all primitive triples.
 *   So, we generate all primitive triples with a perimeter lesser than
 * 1,500,000, and use them to generate all non-primitive triples as well, then
 * count how many had a unique perimeter.
 *
 * Reference: http://mathworld.wolfram.com/PythagoreanTriple.html
 */

#include <iostream>

using namespace std;

const int BOUND = 1500000;
int *arr; // Will be an array of 1,500,000 ints



// Adds the perimeters of all triangles of the form (na, nb, nc), n >= 1, to
// our array
void scale(int a, int b, int c)
{
  int p, q;
  p = q = a + b + c;
  while (p <= BOUND)
  {
    arr[p]++;
    p += q;
  }
}



// Takes a primitive triple (a, b, c) and recursively multiplies it by the
// matrices U, A, D to obtain three new primitive triples.
void mult(int a, int b, int c)
{
  int x, y, z;

  if (a + b + c > BOUND)
    return;

  scale(a, b, c);

  // U
  x =   a - 2*b + 2*c;
  y = 2*a -   b + 2*c;
  z = 2*a - 2*b + 3*c;
  mult(x, y, z);

  // A
  x =   a + 2*b + 2*c;
  y = 2*a +   b + 2*c;
  z = 2*a + 2*b + 3*c;
  mult(x, y, z);

  // D
  x = -  a + 2*b + 2*c;
  y = -2*a +   b + 2*c;
  z = -2*a + 2*b + 3*c;
  mult(x, y, z);
}

int main()
{
  int a = 3, b = 4, c = 5, n = 0;

  // Initialize array
  arr = new int[BOUND+1];
  for (int i = 0; i <= BOUND; i++)
    arr[i] = 0;

  // Solve
  mult(a, b, c);
  for (int i = 0; i <= BOUND; i++)
    if (arr[i] == 1)
      n++;
  cout << n << endl;

  // Clean up
  delete[] arr;
  return 0;
}
